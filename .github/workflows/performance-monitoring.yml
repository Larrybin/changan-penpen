name: Performance Monitoring

on:
  workflow_dispatch:
  schedule:
    # Run daily at 6 AM UTC
    - cron: '0 6 * * *'
  pull_request:
    types: [opened, synchronize]
    paths-ignore:
      - 'docs/**'
      - '*.md'

permissions:
  contents: read
  pull-requests: write

jobs:
  bundle-analysis:
    name: Bundle Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8

      - name: Setup Node.js and pnpm
        uses: ./.github/actions/setup-node-pnpm
        with:
          node-version: 20
          pnpm-version: 10
          cache-key-suffix: "-performance"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Analyze bundle size
        run: |
          set -euo pipefail
          echo "::group::Bundle Analysis"

          # Analyze the bundle
          ANALYZE=true pnpm build

          # Check if build output exists
          if [[ -d ".next" ]]; then
            echo "âœ… Build completed successfully"

            # Find build artifacts
            if [[ -f ".next/static/chunks/pages/_app.js" ]]; then
              app_size=$(stat -c%s ".next/static/chunks/pages/_app.js" 2>/dev/null || echo "0")
              echo "ðŸ“¦ Main app bundle: $(( app_size / 1024 )) KB"
            fi

            # Analyze total .next size
            if command -v du >/dev/null 2>&1; then
              total_size=$(du -sh .next 2>/dev/null | cut -f1 || echo "0")
              echo "ðŸ“Š Total build size: $total_size"
            fi

            # Collect largest JavaScript chunks for reporting
            if [[ -d ".next/static/chunks" ]]; then
              node <<'NODE'
const fs = require("fs");
const path = require("path");

const baseDir = path.join(".next", "static", "chunks");
const reportPath = "performance-report.json";
const sizeThresholdKB = 500;

function collectFiles(directory) {
  const entries = fs.readdirSync(directory, { withFileTypes: true });
  const files = [];

  for (const entry of entries) {
    const entryPath = path.join(directory, entry.name);
    if (entry.isDirectory()) {
      files.push(...collectFiles(entryPath));
      continue;
    }

    if (!entry.isFile()) {
      continue;
    }

    if (!/\.(c|m)?js$/i.test(entry.name)) {
      continue;
    }

    const stats = fs.statSync(entryPath);
    const relativePath = path
      .relative(".next", entryPath)
      .split(path.sep)
      .join("/");

    files.push({ path: relativePath, size: stats.size });
  }

  return files;
}

function toKB(bytes) {
  return Math.round((bytes / 1024) * 10) / 10;
}

const report = {
  generatedAt: new Date().toISOString(),
  sizeThresholdKB,
  largestFiles: [],
  exceedingThreshold: [],
};

if (fs.existsSync(baseDir)) {
  const files = collectFiles(baseDir);
  files.sort((a, b) => b.size - a.size);

  report.largestFiles = files.slice(0, 10).map((file) => ({
    path: file.path,
    sizeBytes: file.size,
    sizeKB: toKB(file.size),
  }));

  report.exceedingThreshold = files
    .filter((file) => toKB(file.size) > sizeThresholdKB)
    .map((file) => ({
      path: file.path,
      sizeBytes: file.size,
      sizeKB: toKB(file.size),
    }));
}

fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));

if (report.largestFiles.length > 0) {
  console.log("Top JavaScript chunks:");
  for (const file of report.largestFiles) {
    console.log(`- ${file.path}: ${file.sizeKB} KB`);
  }

  if (report.exceedingThreshold.length > 0) {
    console.log("\nChunks exceeding threshold:");
    for (const file of report.exceedingThreshold) {
      console.log(`- ${file.path}: ${file.sizeKB} KB (>${sizeThresholdKB} KB)`);
    }
  }
} else {
  console.log("No JavaScript chunks found in .next/static/chunks.");
}
NODE
            fi
          else
            echo "::error::Build failed or .next directory not found"
            exit 1
          fi

          echo "::endgroup::"

      - name: Performance threshold check
        run: |
          set -euo pipefail

          # Define thresholds (in KB)
          MAX_APP_BUNDLE=500  # 500KB for main app bundle
          MAX_TOTAL_SIZE=10000 # 10MB for total build

          if [[ -f ".next/static/chunks/pages/_app.js" ]]; then
            app_size=$(stat -c%s ".next/static/chunks/pages/_app.js" 2>/dev/null || echo "0")
            app_size_kb=$(( app_size / 1024 ))

            if [[ $app_size_kb -gt $MAX_APP_BUNDLE ]]; then
              echo "::warning::App bundle size ($app_size_kb KB) exceeds threshold ($MAX_APP_BUNDLE KB)"
            else
              echo "âœ… App bundle size ($app_size_kb KB) within threshold"
            fi
          fi

      - name: PR Comment on Performance
        if: github.event_name == 'pull_request'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
        with:
          script: |
            const fs = require("fs");

            let comment = '## ðŸ“Š Performance Analysis\n\n';

            // Bundle size information
            if (fs.existsSync('.next/static/chunks/pages/_app.js')) {
              const stats = fs.statSync('.next/static/chunks/pages/_app.js');
              const sizeKB = Math.round(stats.size / 1024);
              comment += `ðŸ“¦ **Main App Bundle**: ${sizeKB} KB\n\n`;
            }

            const reportPath = 'performance-report.json';
            if (fs.existsSync(reportPath)) {
              const report = JSON.parse(fs.readFileSync(reportPath, "utf8"));

              if (Array.isArray(report.largestFiles) && report.largestFiles.length > 0) {
                comment += "### Largest JavaScript Chunks\n";
                comment += "| Chunk | Size (KB) |\n";
                comment += "| --- | ---: |\n";
                report.largestFiles.slice(0, 5).forEach((file) => {
                  comment += `| \`${file.path}\` | ${file.sizeKB} |\n`;
                });
                comment += "\n";
              }

              if (Array.isArray(report.exceedingThreshold) && report.exceedingThreshold.length > 0) {
                comment += `âš ï¸ **Chunks above ${report.sizeThresholdKB} KB**\n`;
                report.exceedingThreshold.forEach((file) => {
                  comment += `- \`${file.path}\`: ${file.sizeKB} KB\n`;
                });
                comment += "\n";
              } else {
                comment += `âœ… All analyzed JavaScript chunks are under ${report.sizeThresholdKB} KB.\n\n`;
              }
            }

            comment += 'This analysis helps track bundle size changes and performance impact.\n\n';
            comment += 'ðŸ“ **Recommendations**:\n';
            comment += '- Keep main bundles under 500KB\n';
            comment += '- Use dynamic imports for large libraries\n';
            comment += '- Optimize images and assets\n';

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            const existingComment = comments.find(comment =>
              comment.body.includes('Performance Analysis') &&
              comment.user.type === 'Bot'
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                comment_id: existingComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment,
              });
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment,
              });
            }
