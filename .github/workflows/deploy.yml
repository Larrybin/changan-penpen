name: Deploy Next.js App to Cloudflare

permissions:
  contents: read

on:
  workflow_dispatch:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: '20'
  PNPM_VERSION: '10'
  NEXT_PUBLIC_APP_URL: ${{ vars.NEXT_PUBLIC_APP_URL || 'http://localhost:3000' }}

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  changes:
    name: Determine changed files
    runs-on: ubuntu-latest
    outputs:
      docs_only: ${{ steps.diff.outputs.docs_only }}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          fetch-depth: 2
      - name: Compute docs-only flag
        id: diff
        shell: bash
        run: |
          set -euo pipefail
          base="${{ github.event.before }}"
          if [ -z "${base}" ]; then
            base=$(git rev-list HEAD~1 -n 1 || true)
          fi
          if [ -z "${base}" ]; then
            echo "docs_only=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          files=$(git diff --name-only "${base}"...HEAD | tr -d '\r' || true)
          echo "Changed files:"; echo "$files"
          if [ -z "${files}" ]; then
            echo "docs_only=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          # Anything outside docs/ or README.md is considered non-docs
          non_docs=$(echo "$files" | grep -Ev '^(README\.md|docs/)' || true)
          if [ -z "${non_docs}" ]; then
            echo "docs_only=true" >> "$GITHUB_OUTPUT"
          else
            echo "docs_only=false" >> "$GITHUB_OUTPUT"
          fi
  # Quality gate — CI
  quality-gate-reusable:
    name: Quality Gate
    needs: changes
    if: needs.changes.outputs.docs_only != 'true'
    uses: ./.github/workflows/ci.yml
    secrets: inherit

  deploy-production:
    name: Deploy Production
    if: ((github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch') && needs.changes.outputs.docs_only != 'true'
    needs: [quality-gate-reusable, changes]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment: production
    permissions:
      contents: read
      deployments: write
    steps:
      - name: Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@36de12bed180fa130ed56a35e7344f2fa7a820ab
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@a0853c24544627f65ddf259abe73b1d18a591444
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Check required secrets (Production)
        run: |
          missing=()
          for var in CLOUDFLARE_API_TOKEN CLOUDFLARE_ACCOUNT_ID BETTER_AUTH_SECRET GOOGLE_CLIENT_ID GOOGLE_CLIENT_SECRET CLOUDFLARE_R2_URL CREEM_API_KEY CREEM_WEBHOOK_SECRET; do
            value="${!var}"
            if [ -z "$value" ]; then
              missing+=("$var")
            fi
          done

          if [ "${#missing[@]}" -eq 0 ]; then
            echo "All required production secrets are present."
            exit 0
          fi

          echo "Production deployment aborted. Missing secrets: ${missing[*]}"
          exit 1
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          CLOUDFLARE_R2_URL: ${{ secrets.CLOUDFLARE_R2_URL }}
          CREEM_API_KEY: ${{ secrets.CREEM_API_KEY }}
          CREEM_WEBHOOK_SECRET: ${{ secrets.CREEM_WEBHOOK_SECRET }}

      - name: Check CREEM_API_URL variable(s)
        shell: bash
        env:
          CREEM_API_URL: ${{ vars.CREEM_API_URL }}
          CREEM_API_URL_PRODUCTION: ${{ vars.CREEM_API_URL_PRODUCTION }}
        run: |
          set -euo pipefail
          url="${CREEM_API_URL:-${CREEM_API_URL_PRODUCTION:-}}"
          if [ -z "$url" ]; then
            echo "Missing CREEM API URL. Configure one of: 'Actions → Variables' → CREEM_API_URL (preferred) or CREEM_API_URL_PRODUCTION."
            exit 1
          fi

      - name: Check NEXT_PUBLIC_APP_URL (Production)
        run: |
          set -euo pipefail
          url="${{ vars.NEXT_PUBLIC_APP_URL }}"
          if [ -z "$url" ]; then
            echo "NEXT_PUBLIC_APP_URL is required for production. Set it in: Settings › Secrets and variables › Actions › Variables."
            exit 1
          fi
          if echo "$url" | grep -Eqi 'localhost|127\\.0\\.0\\.1'; then
            echo "NEXT_PUBLIC_APP_URL must not point to localhost for production: $url"
            exit 1
          fi

      - name: Cache Next.js build
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830
        with:
          path: |
            .next/cache
          key: ${{ runner.os }}-nextjs-${{ hashFiles('pnpm-lock.yaml') }}-${{ hashFiles('**/*.[jt]s', '**/*.[jt]sx', '**/*.ts', '**/*.tsx') }}
          restore-keys: |
            ${{ runner.os }}-nextjs-${{ hashFiles('pnpm-lock.yaml') }}-

      - name: Install dependencies (composite)
        uses: ./.github/actions/install-and-heal

      - name: Generate Cloudflare types
        run: pnpm run cf-typegen
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

      - name: Build Next.js (diagnostic)
        run: pnpm run build
        env:
          NEXT_PUBLIC_APP_URL: ${{ env.NEXT_PUBLIC_APP_URL }}

      - name: Build application
        run: pnpm run build:cf
        env:
          BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          NEXT_PUBLIC_APP_URL: ${{ env.NEXT_PUBLIC_APP_URL }}

      - name: Generate backup filename
        id: backup
        run: |
          ts=$(date -u +%Y%m%d-%H%M%S)
          echo "filename=db-backup-${ts}.sql" >> "$GITHUB_OUTPUT"

      - name: Export production database
        uses: cloudflare/wrangler-action@da0e0dfe58b7a431659754fdf3f186c529afbe65
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          wranglerVersion: '4.42.1'
          command: d1 export next-cf-app --output ${{ steps.backup.outputs.filename }}

      - name: Upload production DB backup
        if: steps.backup.outcome == 'success'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: ${{ steps.backup.outputs.filename }}
          path: ${{ steps.backup.outputs.filename }}
          retention-days: 14

      - name: Run database migrations (Production)
        uses: cloudflare/wrangler-action@da0e0dfe58b7a431659754fdf3f186c529afbe65
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          environment: production
          wranglerVersion: '4.42.1'
          command: d1 migrations apply next-cf-app --env production --remote

      - name: Verify D1 migrations applied (list)
        uses: cloudflare/wrangler-action@da0e0dfe58b7a431659754fdf3f186c529afbe65
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          environment: production
          wranglerVersion: '4.42.1'
          command: d1 migrations list next-cf-app --env production --remote

      - name: Verify critical tables exist (site_settings)
        uses: cloudflare/wrangler-action@da0e0dfe58b7a431659754fdf3f186c529afbe65
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          environment: production
          wranglerVersion: '4.42.1'
          command: d1 execute next-cf-app --env production --remote --command "SELECT name FROM sqlite_master WHERE type='table' AND name='site_settings';"

      - name: Build OpenNext bundle (Cloudflare)
        run: |
          set -euo pipefail
          npx @opennextjs/cloudflare build
        env:
          # Ensure Next.js gets prod URL for correct routing during OpenNext build
          NEXT_PUBLIC_APP_URL: ${{ env.NEXT_PUBLIC_APP_URL }}

      - name: Deploy to Production (code)
        uses: cloudflare/wrangler-action@da0e0dfe58b7a431659754fdf3f186c529afbe65
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          environment: production
          wranglerVersion: '4.42.1'
          command: >-
            deploy --env production
            --var "CREEM_API_URL=${{ vars.CREEM_API_URL || vars.CREEM_API_URL_PRODUCTION }}"
            --var "NEXT_PUBLIC_APP_URL=${{ env.NEXT_PUBLIC_APP_URL }}"
            --var "TRANSLATION_PROVIDER=${{ vars.TRANSLATION_PROVIDER || 'gpt' }}"
            --var "OPENAI_BASE_URL=${{ vars.OPENAI_BASE_URL }}"
        env:
          BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          CLOUDFLARE_R2_URL: ${{ secrets.CLOUDFLARE_R2_URL }}
          CREEM_API_KEY: ${{ secrets.CREEM_API_KEY }}
          CREEM_WEBHOOK_SECRET: ${{ secrets.CREEM_WEBHOOK_SECRET }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

      - name: Sync Production secrets
        if: ${{ vars.SYNC_PRODUCTION_SECRETS != 'false' }}
        run: |
          set -euo pipefail
          sync_if_set () {
            local key="$1"
            # Use parameter expansion to avoid unbound variable under set -u
            local value="${2-}"
            if [ -z "${value:-}" ]; then
              echo "::notice::Skipping secret $key: not provided"
              return 0
            fi
            printf '%s' "$value" | pnpm exec wrangler secret put "$key" --env production --name next-cf-app
          }
          sync_if_set BETTER_AUTH_SECRET "${BETTER_AUTH_SECRET-}"
          sync_if_set GOOGLE_CLIENT_ID "${GOOGLE_CLIENT_ID-}"
          sync_if_set GOOGLE_CLIENT_SECRET "${GOOGLE_CLIENT_SECRET-}"
          sync_if_set CLOUDFLARE_R2_URL "${CLOUDFLARE_R2_URL-}"
          sync_if_set CREEM_API_KEY "${CREEM_API_KEY-}"
          sync_if_set CREEM_WEBHOOK_SECRET "${CREEM_WEBHOOK_SECRET-}"
          sync_if_set OPENAI_API_KEY "${OPENAI_API_KEY-}"
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          CLOUDFLARE_R2_URL: ${{ secrets.CLOUDFLARE_R2_URL }}
          CREEM_API_KEY: ${{ secrets.CREEM_API_KEY }}
          CREEM_WEBHOOK_SECRET: ${{ secrets.CREEM_WEBHOOK_SECRET }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

      - name: Skip production secret sync (disabled)
        if: ${{ vars.SYNC_PRODUCTION_SECRETS == 'false' }}
        run: echo "Skipping production secret sync (set vars.SYNC_PRODUCTION_SECRETS to 'true' to enable)."

      - name: Wait for deployment
        run: sleep 45

      - name: Production health check
        env:
          HC_SECRET: ${{ secrets.PRODUCTION_HEALTHCHECK_URL }}
          HC_VAR: ${{ vars.PRODUCTION_HEALTHCHECK_URL }}
          DEPLOY_HEALTH_RETRIES: ${{ vars.DEPLOY_HEALTH_RETRIES }}
          DEPLOY_HEALTH_RETRY_DELAY: ${{ vars.DEPLOY_HEALTH_RETRY_DELAY }}
          DEPLOY_HEALTH_TIMEOUT: ${{ vars.DEPLOY_HEALTH_TIMEOUT }}
        run: |
          set -euo pipefail

          retries="${DEPLOY_HEALTH_RETRIES:-5}"
          delay="${DEPLOY_HEALTH_RETRY_DELAY:-5}"
          timeout="${DEPLOY_HEALTH_TIMEOUT:-25}"

          url="${HC_SECRET:-${HC_VAR:-}}"
          if [ -z "$url" ]; then
            if [ -z "${NEXT_PUBLIC_APP_URL:-}" ]; then
              echo "No production health check URL configured and NEXT_PUBLIC_APP_URL unset."
              exit 1
            fi
            url="${NEXT_PUBLIC_APP_URL%/}/api/v1/health"
          fi

          echo "Checking production health at $url (strict mode)"
          tmp="$(mktemp)"
          attempt=1
          status="000"
          while [ "$attempt" -le "$retries" ]; do
            echo "Attempt $attempt of $retries"
            status=$(curl -sS --connect-timeout 5 --max-time "$timeout" \
              -o "$tmp" -w "%{http_code}" "$url" || echo "000")
            if [ "$status" = "200" ]; then
              break
            fi
            cat "$tmp" || true
            if [ "$attempt" -ge "$retries" ]; then
              break
            fi
            sleep "$delay"
            attempt=$((attempt + 1))
          done

          if [ "$status" != "200" ]; then
            echo "::error::Production health check failed after $retries attempt(s) (last status: $status)"
            cat "$tmp" || true
            exit 1
          fi

          printf '### Production health check\n\n- URL: [%s](%s)\n- Attempts: %s\n- Status: %s\n' \
            "$url" "$url" "$attempt/$retries" "$status" >> "$GITHUB_STEP_SUMMARY"
          cat "$tmp"

      - name: 生成部署审计摘要
        id: deployment_audit
        run: |
          set -euo pipefail

          head="${{ github.sha }}"
          base="${{ github.event.before }}"
          zero="0000000000000000000000000000000000000000"

          if [ -z "$base" ] || [ "$base" = "$zero" ]; then
            if git rev-parse "${head}^" >/dev/null 2>&1; then
              base=$(git rev-parse "${head}^")
            else
              base="$head"
            fi
          fi

          range=""
          commits=""

          if [ "$base" = "$head" ]; then
            commits=$(git log -1 --pretty=format:'- %h %an %s' "$head" || true)
            range="${head:0:7}"
          else
            commits=$(git log --pretty=format:'- %h %an %s' "${base}..${head}" || true)
            if [ -z "$commits" ]; then
              commits=$(git log -1 --pretty=format:'- %h %an %s' "$head" || true)
              range="${head:0:7}"
            else
              range="${base:0:7}..${head:0:7}"
            fi
          fi

          if [ -z "$commits" ]; then
            commits="- (无可用提交)"
          fi

          version=$(jq -r '.version' package.json 2>/dev/null || echo "unknown")
          actor="${{ github.actor }}"

          printf -v summary '### 部署审计\n\n- 版本号: %s\n- 执行者: %s\n- 提交范围: %s\n\n#### 提交列表\n%s' \
            "${version}" \
            "${actor}" \
            "${range}" \
            "${commits}"

          release_notes=$(node -e "
            const fs = require('fs');
            const path = require('path');
            const changelogPath = path.join(process.cwd(), 'CHANGELOG.md');

            if (!fs.existsSync(changelogPath)) {
              process.exit(0);
            }

            const content = fs.readFileSync(changelogPath, 'utf8');
            const lines = content.split(/\\r?\\n/);
            const start = lines.findIndex((line) => line.startsWith('## '));
            if (start === -1) {
              process.exit(0);
            }
            let end = start + 1;
            while (end < lines.length && !lines[end].startsWith('## ')) {
              end += 1;
            }
            const section = lines.slice(start, end).join('\\n').trim();
            if (section) {
              console.log(section);
            }
            ")

          if [ -n "${release_notes}" ]; then
            printf -v summary '%s\n\n#### 发布说明\n%s' "$summary" "$release_notes"
          else
            printf -v summary '%s\n\n#### 发布说明\n- 未检测到 CHANGELOG 条目' "$summary"
          fi

          printf '%s\n' "$summary" >> "$GITHUB_STEP_SUMMARY"
          printf 'summary_json=%s\n' "$(printf '%s' "$summary" | jq -Rs .)" >> "$GITHUB_OUTPUT"

      - name: 将部署审计写入环境注释
        if: github.ref == 'refs/heads/main' && steps.deployment_audit.outputs.summary_json != ''
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
        env:
          SUMMARY_JSON: ${{ steps.deployment_audit.outputs.summary_json }}
          DEPLOYMENT_ID: ${{ github.deployment_id }}
        with:
          script: |
            const summary = JSON.parse(process.env.SUMMARY_JSON || '""');
            if (!summary) {
              core.warning('缺少部署摘要内容，跳过环境注释。');
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            let deploymentId = process.env.DEPLOYMENT_ID;
            if (!deploymentId) {
              const { data: deploymentsBySha } = await github.rest.repos.listDeployments({
                owner,
                repo,
                sha: context.sha,
                environment: 'production',
                per_page: 1,
              });

              deploymentId = deploymentsBySha?.[0]?.id ? String(deploymentsBySha[0].id) : '';

              if (!deploymentId) {
                const { data: deployments } = await github.rest.repos.listDeployments({
                  owner,
                  repo,
                  environment: 'production',
                  per_page: 1,
                });

                deploymentId = deployments?.[0]?.id ? String(deployments[0].id) : '';
              }
            }

            if (!deploymentId) {
              core.warning('未找到有效的 deployment_id，无法写入环境注释。');
              return;
            }

            const logUrl = `https://github.com/${owner}/${repo}/actions/runs/${context.runId}`;
            const compact = summary.replace(/\s+/g, ' ').trim();
            const description = compact.length > 140 ? `${compact.slice(0, 137)}...` : compact;

            try {
              await github.rest.repos.createDeploymentStatus({
                owner,
                repo,
                deployment_id: Number(deploymentId),
                state: 'success',
                description,
                log_url: logUrl,
                environment: 'production',
                environment_url: `${logUrl}#summary`,
                auto_inactive: false
              });
            } catch (error) {
              const status = error?.status ?? error?.response?.status;
              const message = error?.message || error?.response?.data?.message;
              if (status === 403) {
                core.warning(`缺少写入部署状态的权限，跳过环境注释。(${message || '403 Forbidden'})`);
                return;
              }
              throw error;
            }

      - name: Post-deployment verification
        uses: cloudflare/wrangler-action@da0e0dfe58b7a431659754fdf3f186c529afbe65
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          wranglerVersion: '4.42.1'
          command: --version
