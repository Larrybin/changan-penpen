name: Deploy Next.js App to Cloudflare

permissions:
  contents: read
  deployments: write
  pull-requests: write
  id-token: write

on:
  workflow_dispatch:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: '20'
  PNPM_VERSION: '10'
  NEXT_PUBLIC_APP_URL: ${{ vars.NEXT_PUBLIC_APP_URL || 'http://localhost:3000' }}

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  changes:
    name: Determine changed files
    runs-on: ubuntu-latest
    outputs:
      docs_only: ${{ steps.diff.outputs.docs_only }}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          fetch-depth: 2
      - name: Load workflow configuration
        uses: ./.github/actions/load-workflow-config
      - name: Compute docs-only flag
        id: diff
        shell: bash
        env:
          GITHUB_EVENT_BEFORE: ${{ github.event.before }}
        run: |
          set -euo pipefail
          scripts/workflows/detect-docs-only.sh --base "${GITHUB_EVENT_BEFORE}" >/dev/null
          cat docs_only.txt >> "$GITHUB_OUTPUT"
  # Quality gate — CI
  quality-gate-reusable:
    name: Quality Gate
    needs: changes
    if: needs.changes.outputs.docs_only != 'true'
    uses: ./.github/workflows/ci.yml
    secrets: inherit

  package-artifacts:
    name: Build deployment bundle
    if: ((github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch') && needs.changes.outputs.docs_only != 'true'
    needs: [quality-gate-reusable, changes]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      NEXT_PUBLIC_APP_URL: ${{ vars.NEXT_PUBLIC_APP_URL || 'http://localhost:3000' }}
    outputs:
      build_source: ${{ steps.build_source.outputs.source }}
    steps:
      - name: Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          fetch-depth: 0

      - name: Load workflow configuration
        uses: ./.github/actions/load-workflow-config

      - name: Setup Node.js and pnpm
        uses: ./.github/actions/setup-node-pnpm
        with:
          node-version: ${{ env.NODE_VERSION }}
          pnpm-version: ${{ env.PNPM_VERSION }}
          cache-key-suffix: "-deploy-package"

      - name: Install dependencies (composite)
        uses: ./.github/actions/install-and-heal

      - name: Download CI Next.js build artifact
        id: download_ci_build
        uses: dawidd6/action-download-artifact@688efa90a08f3552e7c1420c8313e215164e8b14
        with:
          workflow: ci.yml
          commit: ${{ github.sha }}
          name: next-build
          path: artifacts/ci
          if_no_artifact_found: warn

      - name: Extract Next.js build artifact
        if: steps.download_ci_build.outputs.found_artifact == 'true'
        run: |
          set -euo pipefail
          tar -xzf artifacts/ci/next-build.tar.gz

      - name: Determine build source
        id: build_source
        run: |
          if [[ '${{ steps.download_ci_build.outputs.found_artifact }}' == 'true' ]]; then
            echo "source=ci-artifact" >> "$GITHUB_OUTPUT"
          else
            echo "source=local" >> "$GITHUB_OUTPUT"
          fi

      - name: Build Next.js (fallback)
        if: steps.download_ci_build.outputs.found_artifact != 'true'
        run: pnpm build

      - name: Generate Cloudflare types
        run: pnpm run cf-typegen
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

      - name: Build Cloudflare bundle
        run: pnpm run build:cf
        env:
          BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          NEXT_PUBLIC_APP_URL: ${{ env.NEXT_PUBLIC_APP_URL }}

      - name: Archive OpenNext bundle
        run: |
          set -euo pipefail
          if [[ ! -d .open-next ]]; then
            echo "::error::OpenNext bundle missing after build"
            exit 1
          fi
          tar -czf open-next-bundle.tar.gz .open-next

      - name: Upload OpenNext bundle
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882
        with:
          name: open-next-bundle
          path: open-next-bundle.tar.gz
          retention-days: 3

  database-prep:
    name: Prepare database
    if: ((github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch') && needs.changes.outputs.docs_only != 'true'
    needs: [quality-gate-reusable, changes]
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Generate backup filename
        id: backup
        run: |
          set -euo pipefail
          ts=$(date -u +%Y%m%d-%H%M%S)
          echo "filename=db-backup-${ts}.sql" >> "$GITHUB_OUTPUT"

      - name: Export production database
        uses: cloudflare/wrangler-action@da0e0dfe58b7a431659754fdf3f186c529afbe65
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          wranglerVersion: '4.42.1'
          command: d1 export next-cf-app --output ${{ steps.backup.outputs.filename }}

      - name: Upload production DB backup
        if: steps.backup.outcome == 'success'
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882
        with:
          name: ${{ steps.backup.outputs.filename }}
          path: ${{ steps.backup.outputs.filename }}
          retention-days: 14

      - name: Run database migrations (Production)
        uses: cloudflare/wrangler-action@da0e0dfe58b7a431659754fdf3f186c529afbe65
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          environment: production
          wranglerVersion: '4.42.1'
          command: d1 migrations apply next-cf-app --env production --remote

      - name: Verify D1 migrations applied (list)
        uses: cloudflare/wrangler-action@da0e0dfe58b7a431659754fdf3f186c529afbe65
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          environment: production
          wranglerVersion: '4.42.1'
          command: d1 migrations list next-cf-app --env production --remote

      - name: Verify critical tables exist (site_settings)
        uses: cloudflare/wrangler-action@da0e0dfe58b7a431659754fdf3f186c529afbe65
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          environment: production
          wranglerVersion: '4.42.1'
          command: d1 execute next-cf-app --env production --remote --command "SELECT name FROM sqlite_master WHERE type='table' AND name='site_settings';"

  deploy-production:
    name: Deploy Production
    if: ((github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch') && needs.changes.outputs.docs_only != 'true'
    needs:
      - package-artifacts
      - database-prep
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment: production
    env:
      NEXT_PUBLIC_APP_URL: ${{ vars.NEXT_PUBLIC_APP_URL || 'http://localhost:3000' }}
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
      GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
      GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
      CLOUDFLARE_R2_URL: ${{ secrets.CLOUDFLARE_R2_URL }}
      CREEM_API_KEY: ${{ secrets.CREEM_API_KEY }}
      CREEM_WEBHOOK_SECRET: ${{ secrets.CREEM_WEBHOOK_SECRET }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
    steps:
      - name: Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          fetch-depth: 0

      - name: Load workflow configuration
        uses: ./.github/actions/load-workflow-config

      - name: Setup Node.js and pnpm
        uses: ./.github/actions/setup-node-pnpm
        with:
          node-version: ${{ env.NODE_VERSION }}
          pnpm-version: ${{ env.PNPM_VERSION }}
          cache-key-suffix: "-deploy"

      - name: Install dependencies (composite)
        uses: ./.github/actions/install-and-heal

      - name: Download OpenNext bundle
        uses: actions/download-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882
        with:
          name: open-next-bundle
          path: artifacts/opennext

      - name: Extract OpenNext bundle
        run: |
          set -euo pipefail
          tar -xzf artifacts/opennext/open-next-bundle.tar.gz

      - name: Check required secrets (Production)
        run: |
          set -eo pipefail
          secrets_json="${PRODUCTION_SECRETS_JSON:-[]}" || secrets_json='[]'
          mapfile -t required_secrets < <(echo "$secrets_json" | jq -r '.[]')
          total=${#required_secrets[@]}
          if [[ $total -eq 0 ]]; then
            echo "::error::No production secrets configured in config/workflow-config.json"
            exit 1
          fi
          missing=()
          for secret_name in "${required_secrets[@]}"; do
            value="${!secret_name-}"
            if [[ -z "${value:-}" ]]; then
              missing+=("$secret_name")
              echo "::warning::Missing required secret: $secret_name"
            else
              echo "::add-mask::$value"
            fi
          done
          if [[ ${#missing[@]} -eq 0 ]]; then
            echo "✅ All required production secrets are present ($total secrets)"
          else
            echo "::error::Production deployment aborted. Missing ${#missing[@]} required secrets: ${missing[*]}"
            exit 1
          fi

      - name: Validate Production Inputs
        uses: ./.github/actions/validate-inputs
        with:
          app-url: ${{ vars.NEXT_PUBLIC_APP_URL }}
          creem-api-url: ${{ vars.CREEM_API_URL || vars.CREEM_API_URL_PRODUCTION }}
          allow-localhost: 'false'

      - name: Deploy to Production (code)
        uses: cloudflare/wrangler-action@da0e0dfe58b7a431659754fdf3f186c529afbe65
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          environment: production
          wranglerVersion: '4.42.1'
          command: >-
            deploy --env production
            --var "CREEM_API_URL=${{ vars.CREEM_API_URL || vars.CREEM_API_URL_PRODUCTION }}"
            --var "NEXT_PUBLIC_APP_URL=${{ env.NEXT_PUBLIC_APP_URL }}"
            --var "TRANSLATION_PROVIDER=${{ vars.TRANSLATION_PROVIDER || 'gpt' }}"
            --var "OPENAI_BASE_URL=${{ vars.OPENAI_BASE_URL }}"
        env:
          BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          CLOUDFLARE_R2_URL: ${{ secrets.CLOUDFLARE_R2_URL }}
          CREEM_API_KEY: ${{ secrets.CREEM_API_KEY }}
          CREEM_WEBHOOK_SECRET: ${{ secrets.CREEM_WEBHOOK_SECRET }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

      - name: Sync Production secrets
        if: ${{ vars.SYNC_PRODUCTION_SECRETS != 'false' }}
        run: |
          set -eo pipefail
          secrets_json="${PRODUCTION_SECRETS_JSON:-[]}" || secrets_json='[]'
          mapfile -t required_secrets < <(echo "$secrets_json" | jq -r '.[]')
          for secret_name in "${required_secrets[@]}"; do
            value="${!secret_name-}"
            if [[ -z "${value:-}" ]]; then
              echo "::notice::Skipping secret $secret_name: not provided"
              continue
            fi
            printf '%s' "$value" | pnpm exec wrangler secret put "$secret_name" --env production --name next-cf-app
          done

      - name: Skip production secret sync (disabled)
        if: ${{ vars.SYNC_PRODUCTION_SECRETS == 'false' }}
        run: echo "Skipping production secret sync (set vars.SYNC_PRODUCTION_SECRETS to 'true' to enable)."

      - name: Production health check
        env:
          HC_SECRET: ${{ secrets.PRODUCTION_HEALTHCHECK_URL }}
          HC_VAR: ${{ vars.PRODUCTION_HEALTHCHECK_URL }}
          DEPLOY_HEALTH_RETRIES: ${{ vars.DEPLOY_HEALTH_RETRIES }}
          DEPLOY_HEALTH_RETRY_DELAY: ${{ vars.DEPLOY_HEALTH_RETRY_DELAY }}
          DEPLOY_HEALTH_TIMEOUT: ${{ vars.DEPLOY_HEALTH_TIMEOUT }}
          DEPLOY_HEALTH_INITIAL_DELAY: ${{ vars.DEPLOY_HEALTH_INITIAL_DELAY }}
        run: |
          set -euo pipefail

          retries="${DEPLOY_HEALTH_RETRIES:-5}"
          delay="${DEPLOY_HEALTH_RETRY_DELAY:-5}"
          timeout="${DEPLOY_HEALTH_TIMEOUT:-25}"
          initial_delay="${DEPLOY_HEALTH_INITIAL_DELAY:-10}"

          if [[ "$initial_delay" -gt 0 ]]; then
            echo "Waiting $initial_delay second(s) before starting health checks"
            sleep "$initial_delay"
          fi

          url="${HC_SECRET:-${HC_VAR:-}}"
          if [ -z "$url" ]; then
            if [ -z "${NEXT_PUBLIC_APP_URL:-}" ]; then
              echo "No production health check URL configured and NEXT_PUBLIC_APP_URL unset."
              exit 1
            fi
            url="${NEXT_PUBLIC_APP_URL%/}/api/v1/health"
          fi

          echo "Checking production health at $url (strict mode)"
          tmp="$(mktemp)"
          attempt=1
          status="000"
          while [ "$attempt" -le "$retries" ]; do
            echo "Attempt $attempt of $retries"
            status=$(curl -sS --connect-timeout 5 --max-time "$timeout" \
              -o "$tmp" -w "%{http_code}" "$url" || echo "000")
            if [ "$status" = "200" ]; then
              break
            fi
            cat "$tmp" || true
            if [ "$attempt" -ge "$retries" ]; then
              break
            fi
            sleep "$delay"
            attempt=$((attempt + 1))
          done

          if [ "$status" != "200" ]; then
            echo "::error::Production health check failed after $retries attempt(s) (last status: $status)"
            cat "$tmp" || true
            exit 1
          fi

          printf '### Production health check\n\n- URL: [%s](%s)\n- Attempts: %s\n- Status: %s\n' \
            "$url" "$url" "$attempt/$retries" "$status" >> "$GITHUB_STEP_SUMMARY"
          cat "$tmp"

      - name: Notify deployment failure by email
        if: failure() && secrets.DEPLOY_ALERT_SMTP_SERVER != '' && vars.DEPLOY_ALERT_RECIPIENTS != ''
        uses: dawidd6/action-send-mail@5d2f5abd00207aef5c29e26e9471a8c1cd01f17b
        with:
          server_address: ${{ secrets.DEPLOY_ALERT_SMTP_SERVER }}
          server_port: ${{ secrets.DEPLOY_ALERT_SMTP_PORT }}
          username: ${{ secrets.DEPLOY_ALERT_SMTP_USERNAME }}
          password: ${{ secrets.DEPLOY_ALERT_SMTP_PASSWORD }}
          subject: "[Deploy] Production health check failed"
          to: ${{ vars.DEPLOY_ALERT_RECIPIENTS }}
          from: ${{ vars.DEPLOY_ALERT_FROM || secrets.DEPLOY_ALERT_SMTP_USERNAME }}
          body: |
            Production deployment for ${{ github.repository }} (run ${{ github.run_id }}) failed the health check stage.
            Logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      - name: Health check notification not configured
        if: failure() && (secrets.DEPLOY_ALERT_SMTP_SERVER == '' || vars.DEPLOY_ALERT_RECIPIENTS == '')
        run: echo "::warning::Deployment health check failed but email notification is not configured."

      - name: 生成部署审计摘要
        id: deployment_audit
        run: |
          set -euo pipefail

          head="${{ github.sha }}"
          base="${{ github.event.before }}"
          zero="0000000000000000000000000000000000000000"

          if [ -z "$base" ] || [ "$base" = "$zero" ]; then
            if git rev-parse "${head}^" >/dev/null 2>&1; then
              base=$(git rev-parse "${head}^")
            else
              base="$head"
            fi
          fi

          range=""
          commits=""

          if [ "$base" = "$head" ]; then
            commits=$(git log -1 --pretty=format:'- %h %an %s' "$head" || true)
            range="${head:0:7}"
          else
            commits=$(git log --pretty=format:'- %h %an %s' "${base}..${head}" || true)
            if [ -z "$commits" ]; then
              commits=$(git log -1 --pretty=format:'- %h %an %s' "$head" || true)
              range="${head:0:7}"
            else
              range="${base:0:7}..${head:0:7}"
            fi
          fi

          if [ -z "$commits" ]; then
            commits="- (无可用提交)"
          fi

          version=$(jq -r '.version' package.json 2>/dev/null || echo "unknown")
          actor="${{ github.actor }}"

          printf -v summary '### 部署审计\n\n- 版本号: %s\n- 执行者: %s\n- 提交范围: %s\n\n#### 提交列表\n%s' \
            "${version}" \
            "${actor}" \
            "${range}" \
            "${commits}"

          release_notes=$(node -e "
            const fs = require('fs');
            const path = require('path');
            const changelogPath = path.join(process.cwd(), 'CHANGELOG.md');

            if (!fs.existsSync(changelogPath)) {
              process.exit(0);
            }

            const content = fs.readFileSync(changelogPath, 'utf8');
            const lines = content.split(/\\r?\\n/);
            const start = lines.findIndex((line) => line.startsWith('## '));
            if (start === -1) {
              process.exit(0);
            }
            let end = start + 1;
            while (end < lines.length && !lines[end].startsWith('## ')) {
              end += 1;
            }
            const section = lines.slice(start, end).join('\\n').trim();
            if (section) {
              console.log(section);
            }
            ")

          if [ -n "${release_notes}" ]; then
            printf -v summary '%s\n\n#### 发布说明\n%s' "$summary" "$release_notes"
          else
            printf -v summary '%s\n\n#### 发布说明\n- 未检测到 CHANGELOG 条目' "$summary"
          fi

          printf '%s\n' "$summary" >> "$GITHUB_STEP_SUMMARY"
          printf 'summary_json=%s\n' "$(printf '%s' "$summary" | jq -Rs .)" >> "$GITHUB_OUTPUT"

      - name: 将部署审计写入环境注释
        if: github.ref == 'refs/heads/main' && steps.deployment_audit.outputs.summary_json != ''
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
        env:
          SUMMARY_JSON: ${{ steps.deployment_audit.outputs.summary_json }}
          DEPLOYMENT_ID: ${{ github.deployment_id }}
        with:
          script: |
            const summary = JSON.parse(process.env.SUMMARY_JSON || '""');
            if (!summary) {
              core.warning('缺少部署摘要内容，跳过环境注释。');
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            let deploymentId = process.env.DEPLOYMENT_ID;
            if (!deploymentId) {
              const { data: deploymentsBySha } = await github.rest.repos.listDeployments({
                owner,
                repo,
                sha: context.sha,
                environment: 'production',
                per_page: 1,
              });

              deploymentId = deploymentsBySha?.[0]?.id ? String(deploymentsBySha[0].id) : '';

              if (!deploymentId) {
                const { data: deployments } = await github.rest.repos.listDeployments({
                  owner,
                  repo,
                  environment: 'production',
                  per_page: 1,
                });

                deploymentId = deployments?.[0]?.id ? String(deployments[0].id) : '';
              }
            }

            if (!deploymentId) {
              core.warning('未找到有效的 deployment_id，无法写入环境注释。');
              return;
            }

            const logUrl = `https://github.com/${owner}/${repo}/actions/runs/${context.runId}`;
            const compact = summary.replace(/\s+/g, ' ').trim();
            const description = compact.length > 140 ? `${compact.slice(0, 137)}...` : compact;

            try {
              await github.rest.repos.createDeploymentStatus({
                owner,
                repo,
                deployment_id: Number(deploymentId),
                state: 'success',
                description,
                log_url: logUrl,
                environment: 'production',
                environment_url: `${logUrl}#summary`,
                auto_inactive: false
              });
            } catch (error) {
              const status = error?.status ?? error?.response?.status;
              const message = error?.message || error?.response?.data?.message;
              if (status === 403) {
                core.warning(`缺少写入部署状态的权限，跳过环境注释。(${message || '403 Forbidden'})`);
                return;
              }
              throw error;
            }

      - name: Post-deployment verification
        uses: cloudflare/wrangler-action@da0e0dfe58b7a431659754fdf3f186c529afbe65
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          wranglerVersion: '4.42.1'
          command: --version
