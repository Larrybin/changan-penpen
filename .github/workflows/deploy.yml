name: Deploy Next.js App to Cloudflare

permissions:
  contents: read
  deployments: write
  pull-requests: write
  id-token: write

on:
  workflow_dispatch:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: '20'
  PNPM_VERSION: '10'
  NEXT_PUBLIC_APP_URL: ${{ vars.NEXT_PUBLIC_APP_URL || 'http://localhost:3000' }}

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  changes:
    name: Determine changed files
    runs-on: ubuntu-latest
    outputs:
      docs_only: ${{ steps.diff.outputs.docs_only }}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          fetch-depth: 2
      - name: Compute docs-only flag
        id: diff
        uses: ./.github/actions/docs-only-check
        with:
          event-name: ${{ github.event_name }}
          before-sha: ${{ github.event.before }}
          head-sha: ${{ github.sha }}
  # Quality gate — CI
  quality-gate-reusable:
    name: Quality Gate
    needs: changes
    if: needs.changes.outputs.docs_only != 'true'
    uses: ./.github/workflows/ci.yml
    secrets: inherit

  deploy-production:
    name: Deploy Production
    if: ((github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch') && needs.changes.outputs.docs_only != 'true'
    needs: [quality-gate-reusable, changes]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          fetch-depth: 0

      - name: Download Next.js build artifact
        id: download-next
        continue-on-error: true
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53
        with:
          name: next-build
          path: .

      - name: Download OpenNext bundle artifact
        id: download-open-next
        continue-on-error: true
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53
        with:
          name: open-next-bundle
          path: .

      - name: Detect downloaded Next.js build
        id: next-build
        run: |
          set -euo pipefail
          if [ "${DOWNLOAD_OUTCOME}" = "failure" ]; then
            echo "Download step reported failure (likely missing artifact); continuing with fresh build"
          fi
          if [ "${DOWNLOAD_OPEN_NEXT_OUTCOME}" = "failure" ]; then
            echo "OpenNext artifact download reported failure (likely missing artifact); will rebuild if needed"
          fi

          if [ -d ".open-next" ]; then
            echo "Detected OpenNext bundle artifact"
            echo "open_next_from_artifact=true" >>"$GITHUB_OUTPUT"
          else
            echo "OpenNext bundle artifact not found"
            echo "open_next_from_artifact=false" >>"$GITHUB_OUTPUT"
          fi

          if [ -d ".next" ]; then
            echo "Reusing Next.js build artifact"
            echo "from_artifact=true" >>"$GITHUB_OUTPUT"
            echo "needs_fresh_build=false" >>"$GITHUB_OUTPUT"
          else
            echo "CI build artifact not found; performing fresh build"
            echo "from_artifact=false" >>"$GITHUB_OUTPUT"
            echo "needs_fresh_build=true" >>"$GITHUB_OUTPUT"
          fi
        env:
          DOWNLOAD_OUTCOME: ${{ steps.download-next.outcome }}
          DOWNLOAD_OPEN_NEXT_OUTCOME: ${{ steps.download-open-next.outcome }}

      - name: Setup Node.js and pnpm
        uses: ./.github/actions/setup-node-pnpm
        with:
          node-version: ${{ env.NODE_VERSION }}
          pnpm-version: ${{ env.PNPM_VERSION }}
          cache-key-suffix: "-deploy"

      - name: Check required secrets (Production)
        run: |
          set -euo pipefail

          # Define required secrets
          declare -A required_secrets=(
            ["CLOUDFLARE_API_TOKEN"]="${CLOUDFLARE_API_TOKEN:-}"
            ["CLOUDFLARE_ACCOUNT_ID"]="${CLOUDFLARE_ACCOUNT_ID:-}"
            ["BETTER_AUTH_SECRET"]="${BETTER_AUTH_SECRET:-}"
            ["GOOGLE_CLIENT_ID"]="${GOOGLE_CLIENT_ID:-}"
            ["GOOGLE_CLIENT_SECRET"]="${GOOGLE_CLIENT_SECRET:-}"
            ["CLOUDFLARE_R2_URL"]="${CLOUDFLARE_R2_URL:-}"
            ["CREEM_API_KEY"]="${CREEM_API_KEY:-}"
            ["CREEM_WEBHOOK_SECRET"]="${CREEM_WEBHOOK_SECRET:-}"
          )

          # Check for missing secrets
          missing=()
          for secret_name in "${!required_secrets[@]}"; do
            secret_value="${required_secrets[$secret_name]}"
            if [[ -z "$secret_value" ]]; then
              missing+=("$secret_name")
              echo "::warning::Missing required secret: $secret_name"
            else
              # Mask the secret value to prevent logging
              echo "::add-mask::$secret_value"
            fi
          done

          if [[ ${#missing[@]} -eq 0 ]]; then
            echo "✅ All required production secrets are present (${#required_secrets[@]} secrets)"
            exit 0
          fi

          echo "::error::Production deployment aborted. Missing ${#missing[@]} required secrets: ${missing[*]}"
          exit 1
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          CLOUDFLARE_R2_URL: ${{ secrets.CLOUDFLARE_R2_URL }}
          CREEM_API_KEY: ${{ secrets.CREEM_API_KEY }}
          CREEM_WEBHOOK_SECRET: ${{ secrets.CREEM_WEBHOOK_SECRET }}

      - name: Validate Production Inputs
        uses: ./.github/actions/validate-inputs
        with:
          app-url: ${{ vars.NEXT_PUBLIC_APP_URL }}
          creem-api-url: ${{ vars.CREEM_API_URL || vars.CREEM_API_URL_PRODUCTION }}
          allow-localhost: 'false'

      - name: Cache Next.js build
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830
        with:
          path: |
            .next/cache
            .next/standalone
            .next/static
          key: ${{ runner.os }}-nextjs-${{ hashFiles('pnpm-lock.yaml') }}-${{ hashFiles('next.config.*', 'package.json', 'tsconfig.json') }}
          restore-keys: |
            ${{ runner.os }}-nextjs-${{ hashFiles('pnpm-lock.yaml') }}-
            ${{ runner.os }}-nextjs-

      - name: Install dependencies (composite)
        uses: ./.github/actions/install-and-heal

      - name: Generate Cloudflare types
        run: pnpm run cf-typegen
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

      - name: Build Next.js (diagnostic)
        if: steps.next-build.outputs.needs_fresh_build == 'true'
        run: pnpm run build
        env:
          NEXT_PUBLIC_APP_URL: ${{ env.NEXT_PUBLIC_APP_URL }}

      - name: Build OpenNext bundle (reusing CI build)
        if: steps.next-build.outputs.from_artifact == 'true' && steps.next-build.outputs.open_next_from_artifact != 'true'
        run: |
          rm -rf .open-next
          npx @opennextjs/cloudflare build --skipNextBuild
        env:
          BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          NEXT_PUBLIC_APP_URL: ${{ env.NEXT_PUBLIC_APP_URL }}

      - name: Build application
        if: steps.next-build.outputs.needs_fresh_build == 'true'
        run: |
          rm -rf .open-next
          pnpm run build:cf -- --skipNextBuild
        env:
          BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          NEXT_PUBLIC_APP_URL: ${{ env.NEXT_PUBLIC_APP_URL }}

      - name: Generate backup filename
        id: backup
        run: |
          ts=$(date -u +%Y%m%d-%H%M%S)
          echo "filename=db-backup-${ts}.sql" >> "$GITHUB_OUTPUT"

      - name: Run Cloudflare database export
        id: export_db
        run: |
          set -euo pipefail

          pnpm exec wrangler d1 export next-cf-app --output "${BACKUP_FILENAME}"
        env:
          BACKUP_FILENAME: ${{ steps.backup.outputs.filename }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

      - name: Upload production DB backup
        if: steps.export_db.outcome == 'success'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: ${{ steps.backup.outputs.filename }}
          path: ${{ steps.backup.outputs.filename }}
          retention-days: 14

      - name: Run Cloudflare database migrations and deploy
        run: |
          set -euo pipefail

          pnpm exec wrangler d1 migrations apply next-cf-app --env production --remote
          pnpm exec wrangler d1 migrations list next-cf-app --env production --remote
          pnpm exec wrangler d1 execute next-cf-app --env production --remote --command "SELECT name FROM sqlite_master WHERE type='table' AND name='site_settings';"

          pnpm exec wrangler deploy --env production \
            --var "CREEM_API_URL=${CREEM_API_URL}" \
            --var "NEXT_PUBLIC_APP_URL=${NEXT_PUBLIC_APP_URL}" \
            --var "TRANSLATION_PROVIDER=${TRANSLATION_PROVIDER}" \
            --var "OPENAI_BASE_URL=${OPENAI_BASE_URL}"
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          CREEM_API_URL: ${{ vars.CREEM_API_URL || vars.CREEM_API_URL_PRODUCTION }}
          NEXT_PUBLIC_APP_URL: ${{ env.NEXT_PUBLIC_APP_URL }}
          TRANSLATION_PROVIDER: ${{ vars.TRANSLATION_PROVIDER || 'gpt' }}
          OPENAI_BASE_URL: ${{ vars.OPENAI_BASE_URL }}
          BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          CLOUDFLARE_R2_URL: ${{ secrets.CLOUDFLARE_R2_URL }}
          CREEM_API_KEY: ${{ secrets.CREEM_API_KEY }}
          CREEM_WEBHOOK_SECRET: ${{ secrets.CREEM_WEBHOOK_SECRET }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

      - name: Sync Production secrets
        if: ${{ vars.SYNC_PRODUCTION_SECRETS != 'false' }}
        run: |
          set -euo pipefail
          sync_if_set () {
            local key="$1"
            # Use parameter expansion to avoid unbound variable under set -u
            local value="${2-}"
            if [ -z "${value:-}" ]; then
              echo "::notice::Skipping secret $key: not provided"
              return 0
            fi
            printf '%s' "$value" | pnpm exec wrangler secret put "$key" --env production --name next-cf-app
          }
          sync_if_set BETTER_AUTH_SECRET "${BETTER_AUTH_SECRET-}"
          sync_if_set GOOGLE_CLIENT_ID "${GOOGLE_CLIENT_ID-}"
          sync_if_set GOOGLE_CLIENT_SECRET "${GOOGLE_CLIENT_SECRET-}"
          sync_if_set CLOUDFLARE_R2_URL "${CLOUDFLARE_R2_URL-}"
          sync_if_set CREEM_API_KEY "${CREEM_API_KEY-}"
          sync_if_set CREEM_WEBHOOK_SECRET "${CREEM_WEBHOOK_SECRET-}"
          sync_if_set OPENAI_API_KEY "${OPENAI_API_KEY-}"
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          CLOUDFLARE_R2_URL: ${{ secrets.CLOUDFLARE_R2_URL }}
          CREEM_API_KEY: ${{ secrets.CREEM_API_KEY }}
          CREEM_WEBHOOK_SECRET: ${{ secrets.CREEM_WEBHOOK_SECRET }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

      - name: Skip production secret sync (disabled)
        if: ${{ vars.SYNC_PRODUCTION_SECRETS == 'false' }}
        run: echo "Skipping production secret sync (set vars.SYNC_PRODUCTION_SECRETS to 'true' to enable)."

      - name: Production health check
        env:
          HC_SECRET: ${{ secrets.PRODUCTION_HEALTHCHECK_URL }}
          HC_VAR: ${{ vars.PRODUCTION_HEALTHCHECK_URL }}
          DEPLOY_HEALTH_RETRIES: ${{ vars.DEPLOY_HEALTH_RETRIES }}
          DEPLOY_HEALTH_RETRY_DELAY: ${{ vars.DEPLOY_HEALTH_RETRY_DELAY }}
          DEPLOY_HEALTH_TIMEOUT: ${{ vars.DEPLOY_HEALTH_TIMEOUT }}
          DEPLOY_HEALTH_INITIAL_DELAY: ${{ vars.DEPLOY_HEALTH_INITIAL_DELAY }}
        run: |
          set -euo pipefail

          retries="${DEPLOY_HEALTH_RETRIES:-5}"
          delay="${DEPLOY_HEALTH_RETRY_DELAY:-5}"
          timeout="${DEPLOY_HEALTH_TIMEOUT:-25}"
          initial_delay="${DEPLOY_HEALTH_INITIAL_DELAY:-15}"

          url="${HC_SECRET:-${HC_VAR:-}}"
          if [ -z "$url" ]; then
            if [ -z "${NEXT_PUBLIC_APP_URL:-}" ]; then
              echo "No production health check URL configured and NEXT_PUBLIC_APP_URL unset."
              exit 1
            fi
            url="${NEXT_PUBLIC_APP_URL%/}/api/v1/health"
          fi

          echo "Checking production health at $url (strict mode)"
          tmp="$(mktemp)"
          attempt=1
          status="000"
          if [[ "$initial_delay" =~ ^[0-9]+$ ]] && [ "$initial_delay" -gt 0 ]; then
            echo "Waiting $initial_delay second(s) before first health check attempt"
            sleep "$initial_delay"
          fi
          while [ "$attempt" -le "$retries" ]; do
            echo "Attempt $attempt of $retries"
            status=$(curl -sS --connect-timeout 5 --max-time "$timeout" \
              -o "$tmp" -w "%{http_code}" "$url" || echo "000")
            if [ "$status" = "200" ]; then
              break
            fi
            cat "$tmp" || true
            if [ "$attempt" -ge "$retries" ]; then
              break
            fi
            sleep "$delay"
            attempt=$((attempt + 1))
          done

          if [ "$status" != "200" ]; then
            echo "::error::Production health check failed after $retries attempt(s) (last status: $status)"
            cat "$tmp" || true
            exit 1
          fi

          printf '### Production health check\n\n- URL: [%s](%s)\n- Attempts: %s\n- Status: %s\n' \
            "$url" "$url" "$attempt/$retries" "$status" >> "$GITHUB_STEP_SUMMARY"
          cat "$tmp"

      - name: 生成部署审计摘要
        id: deployment_audit
        run: |
          set -euo pipefail

          head="${{ github.sha }}"
          base="${{ github.event.before }}"
          zero="0000000000000000000000000000000000000000"

          if [ -z "$base" ] || [ "$base" = "$zero" ]; then
            if git rev-parse "${head}^" >/dev/null 2>&1; then
              base=$(git rev-parse "${head}^")
            else
              base="$head"
            fi
          fi

          range=""
          commits=""

          if [ "$base" = "$head" ]; then
            commits=$(git log -1 --pretty=format:'- %h %an %s' "$head" || true)
            range="${head:0:7}"
          else
            commits=$(git log --pretty=format:'- %h %an %s' "${base}..${head}" || true)
            if [ -z "$commits" ]; then
              commits=$(git log -1 --pretty=format:'- %h %an %s' "$head" || true)
              range="${head:0:7}"
            else
              range="${base:0:7}..${head:0:7}"
            fi
          fi

          if [ -z "$commits" ]; then
            commits="- (无可用提交)"
          fi

          version=$(jq -r '.version' package.json 2>/dev/null || echo "unknown")
          actor="${{ github.actor }}"

          printf -v summary '### 部署审计\n\n- 版本号: %s\n- 执行者: %s\n- 提交范围: %s\n\n#### 提交列表\n%s' \
            "${version}" \
            "${actor}" \
            "${range}" \
            "${commits}"

          release_notes=$(node -e "
            const fs = require('fs');
            const path = require('path');
            const changelogPath = path.join(process.cwd(), 'CHANGELOG.md');

            if (!fs.existsSync(changelogPath)) {
              process.exit(0);
            }

            const content = fs.readFileSync(changelogPath, 'utf8');
            const lines = content.split(/\\r?\\n/);
            const start = lines.findIndex((line) => line.startsWith('## '));
            if (start === -1) {
              process.exit(0);
            }
            let end = start + 1;
            while (end < lines.length && !lines[end].startsWith('## ')) {
              end += 1;
            }
            const section = lines.slice(start, end).join('\\n').trim();
            if (section) {
              console.log(section);
            }
            ")

          if [ -n "${release_notes}" ]; then
            printf -v summary '%s\n\n#### 发布说明\n%s' "$summary" "$release_notes"
          else
            printf -v summary '%s\n\n#### 发布说明\n- 未检测到 CHANGELOG 条目' "$summary"
          fi

          printf '%s\n' "$summary" >> "$GITHUB_STEP_SUMMARY"
          printf 'summary_json=%s\n' "$(printf '%s' "$summary" | jq -Rs .)" >> "$GITHUB_OUTPUT"

      - name: 将部署审计写入环境注释
        if: github.ref == 'refs/heads/main' && steps.deployment_audit.outputs.summary_json != ''
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
        env:
          SUMMARY_JSON: ${{ steps.deployment_audit.outputs.summary_json }}
          DEPLOYMENT_ID: ${{ github.deployment_id }}
        with:
          script: |
            const summary = JSON.parse(process.env.SUMMARY_JSON || '""');
            if (!summary) {
              core.warning('缺少部署摘要内容，跳过环境注释。');
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            let deploymentId = process.env.DEPLOYMENT_ID;
            if (!deploymentId) {
              const { data: deploymentsBySha } = await github.rest.repos.listDeployments({
                owner,
                repo,
                sha: context.sha,
                environment: 'production',
                per_page: 1,
              });

              deploymentId = deploymentsBySha?.[0]?.id ? String(deploymentsBySha[0].id) : '';

              if (!deploymentId) {
                const { data: deployments } = await github.rest.repos.listDeployments({
                  owner,
                  repo,
                  environment: 'production',
                  per_page: 1,
                });

                deploymentId = deployments?.[0]?.id ? String(deployments[0].id) : '';
              }
            }

            if (!deploymentId) {
              core.warning('未找到有效的 deployment_id，无法写入环境注释。');
              return;
            }

            const logUrl = `https://github.com/${owner}/${repo}/actions/runs/${context.runId}`;
            const compact = summary.replace(/\s+/g, ' ').trim();
            const description = compact.length > 140 ? `${compact.slice(0, 137)}...` : compact;

            try {
              await github.rest.repos.createDeploymentStatus({
                owner,
                repo,
                deployment_id: Number(deploymentId),
                state: 'success',
                description,
                log_url: logUrl,
                environment: 'production',
                environment_url: `${logUrl}#summary`,
                auto_inactive: false
              });
            } catch (error) {
              const status = error?.status ?? error?.response?.status;
              const message = error?.message || error?.response?.data?.message;
              if (status === 403) {
                core.warning(`缺少写入部署状态的权限，跳过环境注释。(${message || '403 Forbidden'})`);
                return;
              }
              throw error;
            }

      - name: Post-deployment verification
        uses: cloudflare/wrangler-action@da0e0dfe58b7a431659754fdf3f186c529afbe65
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          wranglerVersion: '4.42.1'
          command: --version
