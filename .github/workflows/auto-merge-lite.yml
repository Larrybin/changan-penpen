name: Auto Merge Lite

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: Pull request number to evaluate/merge
        required: false
  pull_request:
    types: [opened, synchronize, reopened, labeled, ready_for_review]
    branches: [main]

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: auto-merge-lite-${{ github.ref }}
  cancel-in-progress: true

jobs:
  merge-lite:
    name: Merge whitelist-only AutoFix PR
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate and merge if eligible
        id: eval
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const isPR = !!context.payload.pull_request;
            let prNumber = isPR ? context.payload.pull_request.number : Number(core.getInput('pr_number'));
            if (!prNumber) {
              core.info('No PR number provided and not a PR event; skipping.');
              return;
            }

            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            if (pr.draft) { core.info('PR is draft; skip.'); return; }

            // Only handle our autofix rolling PRs (or those explicitly labeled)
            const hasLabel = (pr.labels || []).some(l => l.name === 'auto-merge');
            const isAutofix = pr.head.ref.startsWith('autofix/');
            if (!isAutofix && !hasLabel) { core.info('Not an autofix PR and no auto-merge label; skip.'); return; }

            // Check changed files are whitelist-only
            const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: prNumber, per_page: 100 });
            const whitelist = new Set(['pnpm-lock.yaml', 'auto-fix-summary.md']);
            const extra = files.filter(f => !whitelist.has(f.filename));
            if (extra.length) {
              core.info('Contains non-whitelist files: ' + extra.map(f=>f.filename).join(', '));
              return;
            }

            // Require combined status success on head sha
            const sha = pr.head.sha;
            const { data: status } = await github.rest.repos.getCombinedStatusForRef({ owner, repo, ref: sha });
            if (status.state !== 'success') {
              core.info('Combined status not success: ' + status.state);
              return;
            }

            // Re-fetch mergeability
            const { data: pr2 } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            if (pr2.mergeable === false) {
              core.info('PR not mergeable (conflicts or checks pending).');
              return;
            }

            // Merge (squash)
            try {
              await github.rest.pulls.merge({ owner, repo, pull_number: prNumber, merge_method: 'squash' });
              core.info('Merged PR #' + prNumber);
            } catch (e) {
              core.warning('Merge API failed: ' + (e.message || e));
              return;
            }

            // Delete branch if from same repo
            if (pr.head.repo && pr.head.repo.full_name === `${owner}/${repo}`) {
              try {
                await github.rest.git.deleteRef({ owner, repo, ref: `heads/${pr.head.ref}` });
                core.info('Deleted branch ' + pr.head.ref);
              } catch (e) {
                core.warning('Delete ref failed: ' + (e.message || e));
              }
            }

      - name: Summary
        if: always()
        run: |
          echo "Auto-merge lite evaluated for event: $GITHUB_EVENT_NAME" >> $GITHUB_STEP_SUMMARY
