name: Auto Merge Lite

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: Pull request number to evaluate/merge
        required: false
  pull_request:
    types: [opened, synchronize, reopened, labeled, ready_for_review]
    branches: [main]

permissions:
  contents: write
  pull-requests: write
  statuses: write

concurrency:
  group: auto-merge-lite-${{ github.ref }}
  cancel-in-progress: true

jobs:
  merge-lite:
    name: Merge whitelist-only AutoFix PR
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate and merge if eligible
        id: eval
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const isPR = !!context.payload.pull_request;
            let prNumber = isPR ? context.payload.pull_request.number : Number(core.getInput('pr_number'));
            if (!prNumber) {
              core.info('No PR number provided and not a PR event; skipping.');
              return;
            }

            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            if (pr.draft) { core.info('PR is draft; skip.'); return; }

            const sha = pr.head.sha;
            const targetUrl = `https://github.com/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;
            const ctx = {
              gate: 'auto-merge/gate',
              type: 'auto-merge/type',
              whitelist: 'auto-merge/whitelist',
              checks: 'auto-merge/checks',
              mergeable: 'auto-merge/mergeable',
            };
            const setStatus = async (contextName, state, description) => {
              try {
                await github.rest.repos.createCommitStatus({ owner, repo, sha, state, context: contextName, target_url: targetUrl, description: (description || '').slice(0,140) });
              } catch (e) {
                core.info(`createCommitStatus('${contextName}') failed: ` + (e.message || e));
              }
            };
            // initialize all contexts as pending
            await Promise.all([
              setStatus(ctx.gate, 'pending', 'Evaluating auto-merge gate'),
              setStatus(ctx.type, 'pending', 'Checking PR type/label'),
              setStatus(ctx.whitelist, 'pending', 'Checking whitelist files'),
              setStatus(ctx.checks, 'pending', 'Checking CI combined status'),
              setStatus(ctx.mergeable, 'pending', 'Checking mergeable state'),
            ]);

            // Only handle our autofix rolling PRs (or those explicitly labeled)
            const hasLabel = (pr.labels || []).some(l => l.name === 'auto-merge');
            const isAutofix = pr.head.ref.startsWith('autofix/');
            if (!isAutofix && !hasLabel) {
              core.info('Not an autofix PR and no auto-merge label; skip.');
              await setStatus(ctx.type, 'failure', 'Not autofix and no auto-merge label');
              await setStatus(ctx.gate, 'failure', 'Auto-merge not eligible');
              return;
            }
            await setStatus(ctx.type, 'success', isAutofix ? 'autofix/* branch' : 'has auto-merge label');

            // Check changed files are whitelist-only
            const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: prNumber, per_page: 100 });
            const whitelist = new Set(['pnpm-lock.yaml', 'auto-fix-summary.md']);
            const extra = files.filter(f => !whitelist.has(f.filename));
            if (extra.length) {
              core.info('Contains non-whitelist files: ' + extra.map(f=>f.filename).join(', '));
              await setStatus(ctx.whitelist, 'failure', 'Contains non-whitelist files');
              await setStatus(ctx.gate, 'failure', 'Auto-merge not eligible');
              return;
            }
            await setStatus(ctx.whitelist, 'success', 'Whitelist-only changes');

            // Require combined status success on head sha
            const { data: status } = await github.rest.repos.getCombinedStatusForRef({ owner, repo, ref: sha });
            if (status.state !== 'success') {
              core.info('Combined status not success: ' + status.state);
              await setStatus(ctx.checks, 'failure', `Combined status: ${status.state}`);
              await setStatus(ctx.gate, 'failure', 'Auto-merge not eligible');
              return;
            }
            await setStatus(ctx.checks, 'success', 'All required checks passed');

            // Re-fetch mergeability
            const { data: pr2 } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            if (pr2.mergeable === false) {
              core.info('PR not mergeable (conflicts or checks pending).');
              await setStatus(ctx.mergeable, 'failure', 'PR not mergeable');
              await setStatus(ctx.gate, 'failure', 'Auto-merge not eligible');
              return;
            }
            await setStatus(ctx.mergeable, 'success', 'Mergeable');

            // Merge (squash)
            try {
              await github.rest.pulls.merge({ owner, repo, pull_number: prNumber, merge_method: 'squash' });
              core.info('Merged PR #' + prNumber);
              await setStatus(ctx.gate, 'success', 'Merged by auto-merge');
            } catch (e) {
              core.warning('Merge API failed: ' + (e.message || e));
              await setStatus(ctx.gate, 'failure', 'Merge API failed');
              return;
            }

            // Delete branch if from same repo
            if (pr.head.repo && pr.head.repo.full_name === `${owner}/${repo}`) {
              try {
                await github.rest.git.deleteRef({ owner, repo, ref: `heads/${pr.head.ref}` });
                core.info('Deleted branch ' + pr.head.ref);
              } catch (e) {
                core.warning('Delete ref failed: ' + (e.message || e));
              }
            }

      - name: Summary
        if: always()
        run: |
          echo "Auto-merge lite evaluated for event: $GITHUB_EVENT_NAME" >> $GITHUB_STEP_SUMMARY
