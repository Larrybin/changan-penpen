name: Auto Merge on CI Success

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: auto-merge-ci-${{ github.event.workflow_run.id }}
  cancel-in-progress: true

jobs:
  merge-on-ci:
    name: Merge whitelist-only after CI success
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    timeout-minutes: 5
    env:
      ALLOWED_AUTHORS: github-actions[bot],dependabot[bot],renovate[bot]
      DENY_LABELS: do-not-merge,wip,blocked
      WHITELIST: pnpm-lock.yaml,auto-fix-summary.md
    steps:
      - name: Evaluate and merge after CI
        id: eval
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const allowedAuthors = new Set((process.env.ALLOWED_AUTHORS || '').split(',').map(s => s.trim()).filter(Boolean));
            const denyLabels = new Set((process.env.DENY_LABELS || '').split(',').map(s => s.trim()).filter(Boolean));
            const whitelist = new Set((process.env.WHITELIST || '').split(',').map(s => s.trim()).filter(Boolean));

            const wr = context.payload.workflow_run;
            const headSha = wr.head_sha;

            let prs = [];
            try {
              const list = await github.rest.repos.listPullRequestsAssociatedWithCommit({ owner, repo, commit_sha: headSha });
              prs = (list.data || []).map(pr => pr.number);
            } catch (e) {
              core.info('listPullRequestsAssociatedWithCommit failed: ' + (e.message || e));
            }

            if (!prs.length) { core.info('No associated PRs; skipping.'); return; }

            const sleep = (ms) => new Promise(r => setTimeout(r, ms));

            for (const prNumber of prs) {
              core.info(`\nEvaluating PR #${prNumber} ...`);
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });

              if (pr.draft) { core.info('Draft PR; skip.'); continue; }

              const labelNames = (pr.labels || []).map(l => l.name).filter(Boolean);
              if (labelNames.some(n => denyLabels.has(n))) { core.info('Has deny label; skip.'); continue; }

              const hasLabel = labelNames.includes('auto-merge');
              const isAutofix = (pr.head.ref || '').startsWith('autofix/');
              if (!isAutofix && !hasLabel) { core.info('Not autofix and no auto-merge label; skip.'); continue; }

              const author = pr.user && pr.user.login;
              if (isAutofix && allowedAuthors.size && !allowedAuthors.has(author)) { core.info(`Author ${author} not allowed for autofix; skip.`); continue; }

              const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: prNumber, per_page: 100 });
              const extra = files.filter(f => !whitelist.has(f.filename));
              if (extra.length) { core.info('Contains non-whitelist files: ' + extra.map(f=>f.filename).join(', ')); continue; }

              let mergeable = false;
              let state = 'unknown';
              for (let i = 0; i < 6; i++) { // ~30s max
                const { data: pr2 } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                state = (pr2.mergeable_state || '').toLowerCase();
                if (pr2.mergeable === true && state === 'clean') { mergeable = true; break; }
                if (state === 'blocked' || state === 'dirty') { mergeable = false; break; }
                await sleep(5000);
              }
              if (!mergeable) {
                core.info(`Not mergeable; state=${state}.`);
                try {
                  if (pr.head.repo && pr.head.repo.full_name === `${owner}/${repo}`) {
                    await github.rest.pulls.updateBranch({ owner, repo, pull_number: prNumber });
                    core.info('Attempted update-branch; wait and re-check.');
                    await sleep(5000);
                    const { data: pr3 } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                    const state2 = (pr3.mergeable_state || '').toLowerCase();
                    if (pr3.mergeable === true && state2 === 'clean') {
                      mergeable = true;
                    } else {
                      core.info(`Still not mergeable after update; state=${state2}.`);
                    }
                  }
                } catch (e) {
                  core.info('update-branch failed or not allowed: ' + (e.message || e));
                }
              }
              if (!mergeable) continue;

              try {
                await github.rest.pulls.merge({ owner, repo, pull_number: prNumber, merge_method: 'squash' });
                core.info('Merged PR #' + prNumber);
              } catch (e) {
                core.warning('Merge API failed: ' + (e.message || e));
                continue;
              }

              try {
                if (pr.head.repo && pr.head.repo.full_name === `${owner}/${repo}`) {
                  await github.rest.git.deleteRef({ owner, repo, ref: `heads/${pr.head.ref}` });
                  core.info('Deleted branch ' + pr.head.ref);
                }
              } catch (e) {
                core.warning('Delete ref failed: ' + (e.message || e));
              }
            }

      - name: Summary
        if: always()
        run: |
          echo "Auto-merge on CI evaluated for run: $GITHUB_RUN_ID" >> $GITHUB_STEP_SUMMARY
          echo "CI workflow: ${{ github.event.workflow_run.name }}" >> $GITHUB_STEP_SUMMARY
          echo "Conclusion: ${{ github.event.workflow_run.conclusion }}" >> $GITHUB_STEP_SUMMARY
          echo "Triggered by: $GITHUB_EVENT_NAME" >> $GITHUB_STEP_SUMMARY
          echo "Run URL: https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}" >> $GITHUB_STEP_SUMMARY

