import { writeFileSync } from "node:fs";
import path from "node:path";

import { resolveConfigSync } from "../src/config";
import type { StaticAssetCacheHeadersConfig } from "../src/config/types";

const OUTPUT_PATH = path.join(process.cwd(), "public", "_headers");
const DEFAULT_STATIC_CACHE_SECONDS = 31536000;

type HeaderRule = {
    comment?: string;
    paths: string[];
    headers: Record<string, string>;
};

function toCacheControl(config?: StaticAssetCacheHeadersConfig) {
    const maxAgeRaw = config?.max_age;
    const immutable = Boolean(config?.immutable);
    if (typeof maxAgeRaw === "number" && Number.isFinite(maxAgeRaw)) {
        return { maxAge: Math.max(0, Math.floor(maxAgeRaw)), immutable };
    }
    if (typeof maxAgeRaw === "string") {
        const trimmed = maxAgeRaw.trim();
        if (/^\d+$/.test(trimmed)) {
            return { maxAge: Number.parseInt(trimmed, 10), immutable };
        }
    }
    return { maxAge: DEFAULT_STATIC_CACHE_SECONDS, immutable };
}

function buildRules(): HeaderRule[] {
    const config = resolveConfigSync();
    const cacheConfig = toCacheControl(
        config.performance?.static_assets?.cache_headers,
    );
    const staticCache = [
        "public",
        `max-age=${cacheConfig.maxAge}`,
        ...(cacheConfig.immutable ? ["immutable"] : []),
    ].join(",");

    const securityHeaders: Record<string, string> = {
        "X-Frame-Options": "DENY",
        "X-Content-Type-Options": "nosniff",
        "Referrer-Policy": "strict-origin-when-cross-origin",
        "Permissions-Policy":
            "camera=(), geolocation=(), microphone=(), payment=()",
        "Content-Security-Policy":
            "default-src 'self'; script-src 'self'; style-src 'self' https://fonts.googleapis.com; img-src 'self' data: https:; font-src 'self' https://fonts.gstatic.com data:; connect-src 'self' https://api.cloudflare.com https://*.upstash.io; frame-ancestors 'none'; form-action 'self'; base-uri 'self'; object-src 'none'",
    };

    return [
        {
            comment:
                "# Next.js static assets - long cache for immutable content",
            paths: ["/_next/static/*"],
            headers: { "Cache-Control": staticCache },
        },
        {
            comment: "# Static images and assets",
            paths: ["/images/*"],
            headers: { "Cache-Control": staticCache },
        },
        {
            comment: "# Font files",
            paths: ["*.woff", "*.woff2", "*.ttf", "*.otf"],
            headers: { "Cache-Control": staticCache },
        },
        {
            comment: "# CSS and JS files",
            paths: ["*.css", "*.js"],
            headers: { "Cache-Control": staticCache },
        },
        {
            comment: "# Open Graph image - short cache for updates",
            paths: ["/og-image.svg"],
            headers: {
                "Cache-Control": "public,max-age=86400,must-revalidate",
            },
        },
        {
            comment: "# Sitemap and robots.txt - short cache for updates",
            paths: ["/sitemap.xml", "/robots.txt"],
            headers: {
                "Cache-Control": "public,max-age=86400,must-revalidate",
            },
        },
        {
            comment: "# API responses",
            paths: ["/api/*"],
            headers: {
                "Cache-Control": "public,max-age=3600,must-revalidate",
            },
        },
        {
            comment: "# HTML pages - short cache for content updates",
            paths: ["/*"],
            headers: {
                "Cache-Control": "public,max-age=3600,must-revalidate",
            },
        },
        {
            comment: "# Security headers",
            paths: ["/*"],
            headers: securityHeaders,
        },
    ];
}

function serializeRules(rules: HeaderRule[]): string {
    const lines: string[] = [
        "# Generated by scripts/generate-headers.ts",
        "# Enhanced caching headers for SEO and performance",
        "",
    ];

    for (const rule of rules) {
        if (rule.comment) {
            lines.push(rule.comment);
        }
        for (const pathEntry of rule.paths) {
            lines.push(pathEntry);
            for (const [header, value] of Object.entries(rule.headers)) {
                lines.push(`  ${header}: ${value}`);
            }
        }
        lines.push("");
    }

    return `${lines.join("\n").trimEnd()}\n`;
}

function main() {
    const rules = buildRules();
    const content = serializeRules(rules);
    writeFileSync(OUTPUT_PATH, content, "utf8");
    console.info(
        `[config] Wrote static headers to ${path.relative(
            process.cwd(),
            OUTPUT_PATH,
        )}`,
    );
}

main();
